/**Light Switch NL2 Script**
	Author: David Wolfe (Red-Thirten)
	Date: 12/21/2022
	Detects user input to switch, animates switch SCO, plays sounds, and controls the lights of specified SCOs in the simulation.
	Licensed under GNU GPLv3 - See LICENSE for more details.
*/

import com.nolimitscoaster.Script;
import com.nolimitscoaster.SceneObject;
import com.nolimitscoaster.SceneObjectElement;
import com.nolimitscoaster.StaticSound;
import com.nolimitscoaster.Button;

import util.RayCast;
import util.OperatorSwitch;
import util.LightGroup;

public class LightSwitch extends Script{	
	protected String SCRIPT_NAME = "LightSwitch";				// Script name for debugging
	protected String SWITCH_ELEMENT_PREFIX = "switch";			// Prefix of the switch element names in the SCO/model
	protected String CURSOR_ELEMENT_PREFIX = "cursor";			// Prefix of the cursor element names in the SCO/model
	protected float ON_ANGLE = 0.f;								// Angle from the model's original switch position to appear on
	protected float OFF_ANGLE = 75.f;							// Angle from the model's original switch position to appear off
	protected float COOLDOWN = 0.25f;							// Cooldown (in seconds) before the switch can be switched again
	protected float ACTIVE_DIST = 0.9f;							// Distance (in meters) between the player and the switch where the switch is active
	protected float CURSOR_SIZE = 0.03f;						// Ray cast hitbox size
	protected float SWITCH_TRAVEL_TIME = 0.025f;				// Time (in seconds) for the switch to travel ("speed")
	protected int AXIS = 0;										// Axis values: 0 = x, 1 = y, 2 = z
	
	protected SceneObject sco;
	private SceneObjectElement[] cursors;
	private StaticSound soundOn, soundOff;
	
	private bool flipped, firstSwitchViewed = false;
	private float curCooldownTime = 0.f;
	
	private RayCast[] rays;
	protected OperatorSwitch[] switches;
	protected LightGroup[] switchLights;
	
	public bool onLateInit(){ // On initialization of Play simulation
		sco = getScoFromParentEntity(); // Get and assign local sco
		
		int numSwitches = 1;
		if (getElementOnScoForName(sco, SWITCH_ELEMENT_PREFIX + numSwitches) == null) return false; // Check for at least one switch
		while (sco.getElementForName(SWITCH_ELEMENT_PREFIX + numSwitches) != null) numSwitches++; // Find number of switches
		--numSwitches;
		cursors = new SceneObjectElement[numSwitches]; // Initialize arrays
		rays = new RayCast[numSwitches];
		switches = new OperatorSwitch[numSwitches];
		switchLights = new LightGroup[numSwitches];
		
		for (int i = 0; i < numSwitches; i++){ // Iterate through switches for setup			
			SceneObjectElement switchElem = sco.getElementForName(SWITCH_ELEMENT_PREFIX + (i+1));
			switches[i] = new OperatorSwitch( // Setup switches
				switchElem,
				2,
				sco.getBooleanParameter("initial_state" + (i+1)).boolValue() ? 1 : 0,
				OFF_ANGLE,
				ON_ANGLE,
				AXIS,
				SWITCH_TRAVEL_TIME
			);
			
			cursors[i] = getElementOnScoForName(sco, CURSOR_ELEMENT_PREFIX + (i+1)); // Get cursor elements
			if (cursors[i] != null){ // Make cursors invisible if valid
				cursors[i].setVisible(false);
			}
			else return false;
			
			rays[i] = new RayCast(switchElem); // Setup rays
			
			// Setup light groups
			String lightsName = sco.getStringParameter("lights_name" + (i+1));
			if (lightsName.length() > 0){
				SceneObject[] lightSCOs = sim.getSceneObjectsWithName(lightsName);
				if (lightSCOs.length != 0){
					switchLights[i] = new LightGroup(
						lightSCOs,
						SWITCH_TRAVEL_TIME / 2,
						sco.getDoubleParameter("flicker_time").floatValue(),
						sco.getDoubleParameter("override_interval").floatValue(),
						!sco.getBooleanParameter("disable_ent_color").boolValue(),
						(switches[i].getSwitchState() != 0)
					);
				}
				else{
					System.err.println(SCRIPT_NAME + ": (Switch " + (i+1) + ") Could not find any light SCOs with the name \"" + lightsName + "\"!");
					return false;
				}
			}
		}
		
		// Set up on and off sounds effects
		soundOn = StaticSound.loadFromResource(sco.getResourcePathParameter("switch_on_sfx_file"), StaticSound.FLAG_MIXDOWN_MONO);
		soundOff = StaticSound.loadFromResource(sco.getResourcePathParameter("switch_off_sfx_file"), StaticSound.FLAG_MIXDOWN_MONO);
		if (soundOn == null || soundOff == null){
			System.err.println(SCRIPT_NAME + ": Failed to load sound files!");
			return false;
		}
		
		soundOn.setDistanceParameters(1.f, 1.f);
		soundOn.setGain(1.f);
		soundOn.setPitch(1.f);
		soundOn.setDopplerMode(false);
		soundOn.setEnvironmentMode(StaticSound.E_ENVMODE_LOCAL);
		
		soundOff.setDistanceParameters(1.f, 1.f);
		soundOff.setGain(1.f);
		soundOff.setPitch(1.f);
		soundOff.setDopplerMode(false);
		soundOff.setEnvironmentMode(StaticSound.E_ENVMODE_LOCAL);
		
		return true;
	}
	
	protected SceneObject getScoFromParentEntity(){ // Returns the SceneObject via the parent entity ID with error handling
        SceneObject sco = sim.getSceneObjectForEntityId(getParentEntityId());
        if (sco == null){
            System.err.println(SCRIPT_NAME + ": This script only works with NL2 scene objects");
        }
        return sco;
    }
	
	protected SceneObjectElement getElementOnScoForName(SceneObject sco, String name){ // Basically getElementForName() with error handling - Gratz to bestdani for idea
        SceneObjectElement element = sco.getElementForName(name);
        if (element == null){
            System.err.println(SCRIPT_NAME + ": Wrong 3d model loaded (Cannot find \"" + name + "\" element)");
        }
        return element;
    }

	public void onNextFrame(float tick){
		if (flipped){
			curCooldownTime = curCooldownTime + tick;
			if (curCooldownTime > COOLDOWN){
				curCooldownTime = 0.f;
				flipped = false;
			}
		}
		
		if(sim.isViewerInsideSphere(sco.getTranslation(), ACTIVE_DIST)){
			firstSwitchViewed = false; // Prevents multiple switches from being viewed & clicked at the same time
			for (int i = rays.length-1; i >= 0; --i){
				if (!flipped && !firstSwitchViewed && rays[i].isViewerLookingAt(CURSOR_SIZE)){
					cursors[i].setVisible(true);
					if (Button.isPressed(Button.ACTION)){
						if (switches[i].getSwitchState() != 0){
							switches[i].setSwitchState(0);
							soundOff.setPosition(switches[i].getSwitchAbsTrans());
							soundOff.play();
						}
						else{
							switches[i].setSwitchState(1);
							soundOn.setPosition(switches[i].getSwitchAbsTrans());
							soundOn.play();
						}
						if (switchLights[i] != null) switchLights[i].toggleLights();
						flipped = true;
					}
					firstSwitchViewed = true;
				}
				else{
					cursors[i].setVisible(false);
				}
			}
		}
		
		for (int i = switches.length-1; i >= 0; --i){ // Run each switch and switchLight objects' onNextFrame() to animate
			switches[i].onNextFrame(tick);
			if (switchLights[i] != null) switchLights[i].onNextFrame(tick);
		}
	}	
}